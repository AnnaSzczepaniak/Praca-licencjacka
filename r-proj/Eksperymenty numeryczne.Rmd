---
title: "Dekompozycja QR- Metoda Householdera"
author: "Ania Szczepaniak"
date: "3 wrzeœnia 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



Szukamy przekszta³cenia pierwszego wektora, tj. pierwszej kolumny.

```{r}
house = function(x) {
  norm_x = sqrt(t(x) %*% x)
  if (x[1] > 0) {
    x[1] = x[1] + norm_x;
  } else {
    x[1] = x[1] - norm_x;
  }
  return(x)
}
```

Tworzymy rozk³ad QR korzystaj¹c z transformacji Householdera 


```{r}
qr_householer = function(A)
{
  R = A
  dimm = dim(A)
  n = dimm[2]
  m = dimm[1]
  Q = diag(n)
  for (i in 1:min(m-1,n)){
    u = house(R[i:m,i])
    den =  (t(u) %*% u)[1,1]
    P = diag(n+1-i) - 2/den * ( u%*% t(u)  ) 
    R[i:m,i:n] = P %*% R[i:m,i:n]
    if (i>1)
      Q[i:n,1:(i-1)] = P %*% Q[i:n,1:(i-1)]
    Q[i:n,i:n] = P %*% Q[i:n,i:n]
  }
  return(list(R=R, Q=t(Q)))
}
qr_householer(A)
qr.Q(qr(A))
```


Tworzymy macierz rotacji Givensa

```{r}

givens = function(i,j,A){
  dimm = dim(A)
  n = dimm[1]
  G = diag(n)
  p = sqrt((A[i,i])^2 + (A[j,i])^2)
  G[i,i] = A[i,i]/ p
  G[i,j] = (A[j,i])/p
  G[j,i] = -(A[j,i])/p
  G[j,j] = A[i,i]/ p
  
return(G)  
  
}
A= matrix(c(1,2,2,2,2,1,2,1,2), 3,3, byrow = TRUE)
A
G = givens(1,2,A)
G
A2= G %*% A
A2
G = givens(1,3,A2)
A3 = G%*% A2
A3
```

```{r}
givens(3,1,A) %*% A
```


Tworzymy algorytm dekompozycji macierzy QR metod¹ rotacji Givensa.

```{r}
qr_givens = function(A){
  R = A
  
  n = dim(A)[2]
  m = dim(A)[1]
  Q = diag(n)
  for (i in 1:(n-1)) {
    for (j in (i+1):m) {
      G = givens(i,j,R)
      R = G %*% R
      Q = Q %*% t(G)
    }
  }
  return(list(R=R, Q=Q))
}

qr_givens(A)
```

Teraz czas na eksperymenty, które poka¿¹, jak bardzo ró¿ni siê b³¹d naszych algorytmów  od tego z gotowej funkcji R Studio, s³u¿¹cej do rozk³adu QR. 
Do wy¿ej wymienionych eksperymentów wykorzystamy losowo wybrane trzy macierze. 
1. Wymiarów 5 na 5.
2. Wymiarów 25 na 25.
3. Wymiarów 125 na 125. 

Na pocz¹tek zajmijmy siê macierz¹ wymiarów 5 na 5.
```{r}
M_1<-matrix(c(replicate(5, rnorm(5)) ), 5, 5, byrow=TRUE) 
M_1
```

Najpierw przeprowadŸmy rozk³ad wbudowan¹ funkcj¹ w R Studio.

```{r}
QR = qr(M_1)
qr.Q(QR)
qr.R(QR)
```


Nastêpnie przeprowadzimy rozk³ad naszym algorytmem qr_givens
```{r}
wynik1_givens = qr_givens(M_1)
wynik1_givens$Q
wynik1_givens$R
```

Rozk³ad algorytmem qr_householder:

```{r}
wynik1_householder = qr_householer(M_1)
wynik1_householder$Q
wynik1_householder$R
```




SprawdŸmy, który rozk³ad jest najbli¿szy naszej wyjœciowej macierzy A.

Policzymy b³¹d bezwgldêny z rozk³adu QR metod¹ rotacji Givensa:

```{r}
M_1_givens = wynik1_givens$Q  %*% wynik1_givens$R
M_11 = M_1_givens - M_1
blad_givens_M_1 = norm(M_11)
blad_givens_M_1
```

B³¹d bezwzglêdny z rozk³adu QR funkcj¹ wbudowan¹ w jêzyk R:

```{r}
M_1_qr = qr.Q(QR) %*% qr.R(QR)
M_12 = M_1_qr - M_1
blad_qr_M_1 = norm(M_12)
blad_qr_M_1
```

B³¹d bezwzglêdy z rozk³adu QR metod¹ odbiæ Householdera:

```{r}
M_1_householder = wynik1_householder$Q %*% wynik1_householder$R
M_13 = M_1_householder - M_1
blad_householder_M_1 = norm(M_13)
blad_householder_M_1

```

SprawdŸmy, który z b³êdów jest najmniejszy, a który najwiêkszy. Bêdziemy wtedy w stanie oceniæ, który z rozk³adów jest na najdok³adniejszy.

```{r}
min(blad_givens_M_1, blad_householder_M_1, blad_qr_M_1)
max(blad_givens_M_1, blad_householder_M_1, blad_qr_M_1)

```

Widzimy, ¿e gotowy algorytm, wbudowany w RStudio jest jednak dok³adniejszy od naszych, samodzielnie napisanych. Widaæ równie¿, ¿e algorytm dekompozycji QR metod¹ Givensa jest jednak dok³adniejszy od algorytmu metod¹ odbiæ Householdera.

Sprawdzimy czy ta zaleŸnoœæ znajduje zastosowania dla macierzy wy¿szych rzêdów.

Kolej na macierzy wymiarów 25 na 25.

```{r}
M_2<-matrix(c(replicate(25, rnorm(25)) ), 25, 25, byrow=TRUE) 
```

Rozk³ad wbudowan¹ funkcj¹ w R Studio:

```{r}
QR = qr(M_2)
qr.Q(QR)
qr.R(QR)
```

Rozk³ad algorytmem qr_givens:

```{r}
wynik2_givens = qr_givens(M_2)
wynik2_givens$Q
wynik2_givens$R
```

Rozk³ad algorytmem qr_householder:

```{r}
wynik2_householder = qr_householer(M_2)
wynik2_householder$Q
wynik2_householder$R
```


B³¹d bezwgldêny z rozk³adu QR metod¹ rotacji Givensa:


```{r}
M_2_givens = wynik2_givens$Q  %*% wynik2_givens$R
M_21 = M_2_givens - M_2
blad_givens_M_2 = norm(M_21)
blad_givens_M_2
```

B³¹d bezwzglêdny z rozk³adu QR funkcj¹ wbudowan¹ w jêzyk R:

```{r}
M_2_qr = qr.Q(QR) %*% qr.R(QR)
M_22 = M_2_qr - M_2
blad_qr_M_2 = norm(M_22)
blad_qr_M_2
```

B³¹d bezwzglêdy z rozk³adu QR metod¹ odbiæ Householdera:

```{r}
M_2_householder = wynik2_householder$Q %*% wynik2_householder$R
M_23 = M_2_householder - M_2
blad_householder_M_2 = norm(M_23)
blad_householder_M_2

```

Porównajmy uzyskane b³êdy:

```{r}
min(blad_givens_M_2,blad_householder_M_2, blad_qr_M_2)
max(blad_givens_M_2,blad_householder_M_2, blad_qr_M_2)
```


W koñcu sprawdŸmy jak wygl¹daj¹ rozk³ady QR macierzy wymiarów 125 na 125.

```{r}
M_3<-matrix(c(replicate(125, rnorm(125)) ), 125, 125, byrow=TRUE) 
```

Rozk³ad funkcj¹ qr:

```{r}
QR = qr(M_3)
qr.Q(QR)
qr.R(QR)
```

Rozk³ad algorytmem qr_givens:

```{r}
wynik3_givens = qr_givens(M_3)
wynik3_givens$Q
wynik3_givens$R
```

Rozk³ad algorytmem qr_householder:

```{r}
wynik3_householder = qr_householer(M_3)
wynik3_householder$Q
wynik3_householder$R
```

B³¹d bezwgldêny z rozk³adu QR metod¹ rotacji Givensa:

```{r}
M_3_givens = wynik3_givens$Q  %*% wynik3_givens$R
M_31 = M_3_givens - M_3
blad_givens_M_3 = norm(M_31)
blad_givens_M_3
```

B³¹d bezwzglêdny z rozk³adu QR funkcj¹ wbudowan¹ w jêzyk R:

```{r}
M_3_qr = qr.Q(QR) %*% qr.R(QR)
M_32 = M_3_qr - M_3
blad_qr_M_3 = norm(M_32)
blad_qr_M_3
```

B³¹d bezwzglêdy z rozk³adu QR metod¹ odbiæ Householdera:

```{r}
M_3_householder = wynik3_householder$Q %*% wynik3_householder$R
M_33 = M_3_householder - M_3
blad_householder_M_3 = norm(M_33)
blad_householder_M_3

```

```{r}
min(blad_givens_M_3,blad_householder_M_3,blad_qr_M_3)
max(blad_givens_M_3,blad_householder_M_3,blad_qr_M_3)

```