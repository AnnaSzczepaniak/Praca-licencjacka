---
title: "Dekompozycja QR- Metoda Householdera"
author: "Ania Szczepaniak"
date: "3 wrze?nia 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



Szukamy przekszta?cenia pierwszego wektora, tj. pierwszej kolumny.

```{r}
house = function(x) {
  norm_x = sqrt(t(x) %*% x)
  if (x[1] > 0) {
    x[1] = x[1] + norm_x;
  } else {
    x[1] = x[1] - norm_x;
  }
  return(x)
}
```

Tworzymy rozk?ad QR korzystaj?c z transformacji Householdera 


```{r}
qr_householer = function(A)
{
  R = A
  dimm = dim(A)
  n = dimm[2]
  m = dimm[1]
  Q = diag(n)
  for (i in 1:min(m-1,n)){
    u = house(R[i:m,i])
    den =  (t(u) %*% u)[1,1]
    P = diag(n+1-i) - 2/den * ( u%*% t(u)  ) 
    R[i:m,i:n] = P %*% R[i:m,i:n]
    if (i>1) 
      Q[i:n,1:(i-1)] = P %*% Q[i:n,1:(i-1)]
    Q[i:n,i:n] = P %*% Q[i:n,i:n]
  }
  return(list(R=R, Q=t(Q)))
}
qr_householer(A)
qr.Q(qr(A))
```


Tworzymy macierz rotacji Givensa

```{r}

givens = function(i,j,A){
  dimm = dim(A)
  n = dimm[1]
  G = diag(n)
  p = sqrt((A[i,i])^2 + (A[j,i])^2)
  G[i,i] = A[i,i]/ p
  G[i,j] = (A[j,i])/p
  G[j,i] = -(A[j,i])/p
  G[j,j] = A[i,i]/ p
  
return(G)  
  
}
A= matrix(c(1,2,2,2,2,1,2,1,2), 3,3, byrow = TRUE)
A
G = givens(1,2,A)
G
A2= G %*% A
A2
G = givens(1,3,A2)
A3 = G%*% A2
A3
```

```{r}
givens(3,1,A) %*% A
```


Tworzymy algorytm dekompozycji macierzy QR metod? rotacji Givensa.

```{r}
qr_givens = function(A){
  R = A
  
  n = dim(A)[2]
  m = dim(A)[1]
  Q = diag(n)
  for (i in 1:(n-1)) {
    for (j in (i+1):m) {
      G = givens(i,j,R)
      R = G %*% R
      Q = Q %*% t(G)
    }
  }
  return(list(R=R, Q=Q))
}

qr_givens(A)
```

Teraz czas na eksperymenty, kt?re poka??, jak bardzo r??ni si? b??d naszych algorytm?w  od tego z gotowej funkcji R Studio, s?u??cej do rozk?adu QR. 
Do wy?ej wymienionych eksperyment?w wykorzystamy losowo wybrane trzy macierze. 
1. Wymiar?w 5 na 5.
2. Wymiar?w 25 na 25.
3. Wymiar?w 125 na 125. 

Na pocz?tek zajmijmy si? macierz? wymiar?w 5 na 5.
```{r}
M_1<-matrix(c(replicate(5, rnorm(5)) ), 5, 5, byrow=TRUE) 
M_1
```

Najpierw przeprowad?my rozk?ad wbudowan? funkcj? w R Studio.

```{r}
QR = qr(M_1)
qr.Q(QR)
qr.R(QR)
```


Nast?pnie przeprowadzimy rozk?ad naszym algorytmem qr_givens
```{r}
wynik1_givens = qr_givens(M_1)
wynik1_givens$Q
wynik1_givens$R
```

Rozk?ad algorytmem qr_householder:

```{r}
wynik1_householder = qr_householer(M_1)
wynik1_householder$Q
wynik1_householder$R
```




Sprawd?my, kt?ry rozk?ad jest najbli?szy naszej wyj?ciowej macierzy A.

Policzymy b??d bezwgld?ny z rozk?adu QR metod? rotacji Givensa:

```{r}
M_1_givens = wynik1_givens$Q  %*% wynik1_givens$R
M_11 = M_1_givens - M_1
blad_givens_M_1 = norm(M_11)
blad_givens_M_1
```

B??d bezwzgl?dny z rozk?adu QR funkcj? wbudowan? w j?zyk R:

```{r}
M_1_qr = qr.Q(QR) %*% qr.R(QR)
M_12 = M_1_qr - M_1
blad_qr_M_1 = norm(M_12)
blad_qr_M_1
```

B??d bezwzgl?dy z rozk?adu QR metod? odbi? Householdera:

```{r}
M_1_householder = wynik1_householder$Q %*% wynik1_householder$R
M_13 = M_1_householder - M_1
blad_householder_M_1 = norm(M_13)
blad_householder_M_1

```

Sprawd?my, kt?ry z b??d?w jest najmniejszy, a kt?ry najwi?kszy. B?dziemy wtedy w stanie oceni?, kt?ry z rozk?ad?w jest na najdok?adniejszy.

```{r}
min(blad_givens_M_1, blad_householder_M_1, blad_qr_M_1)
max(blad_givens_M_1, blad_householder_M_1, blad_qr_M_1)

```

Widzimy, ?e gotowy algorytm, wbudowany w RStudio jest jednak dok?adniejszy od naszych, samodzielnie napisanych. Wida? r?wnie?, ?e algorytm dekompozycji QR metod? Givensa jest jednak dok?adniejszy od algorytmu metod? odbi? Householdera.

Sprawdzimy czy ta zale?no?? znajduje zastosowania dla macierzy wy?szych rz?d?w.

Kolej na macierzy wymiar?w 25 na 25.

```{r}
M_2<-matrix(c(replicate(25, rnorm(25)) ), 25, 25, byrow=TRUE) 
```

Rozk?ad wbudowan? funkcj? w R Studio:

```{r}
QR = qr(M_2)
qr.Q(QR)
qr.R(QR)
```

Rozk?ad algorytmem qr_givens:

```{r}
wynik2_givens = qr_givens(M_2)
wynik2_givens$Q
wynik2_givens$R
```

Rozk?ad algorytmem qr_householder:

```{r}
wynik2_householder = qr_householer(M_2)
wynik2_householder$Q
wynik2_householder$R
```


B??d bezwgld?ny z rozk?adu QR metod? rotacji Givensa:


```{r}
M_2_givens = wynik2_givens$Q  %*% wynik2_givens$R
M_21 = M_2_givens - M_2
blad_givens_M_2 = norm(M_21)
blad_givens_M_2
```

B??d bezwzgl?dny z rozk?adu QR funkcj? wbudowan? w j?zyk R:

```{r}
M_2_qr = qr.Q(QR) %*% qr.R(QR)
M_22 = M_2_qr - M_2
blad_qr_M_2 = norm(M_22)
blad_qr_M_2
```

B??d bezwzgl?dy z rozk?adu QR metod? odbi? Householdera:

```{r}
M_2_householder = wynik2_householder$Q %*% wynik2_householder$R
M_23 = M_2_householder - M_2
blad_householder_M_2 = norm(M_23)
blad_householder_M_2

```

Por?wnajmy uzyskane b??dy:

```{r}
min(blad_givens_M_2,blad_householder_M_2, blad_qr_M_2)
max(blad_givens_M_2,blad_householder_M_2, blad_qr_M_2)
```


W ko?cu sprawd?my jak wygl?daj? rozk?ady QR macierzy wymiar?w 125 na 125.

```{r}
M_3<-matrix(c(replicate(125, rnorm(125)) ), 125, 125, byrow=TRUE) 
```

Rozk?ad funkcj? qr:

```{r}
QR = qr(M_3)
qr.Q(QR)
qr.R(QR)
```

Rozk?ad algorytmem qr_givens:

```{r}
wynik3_givens = qr_givens(M_3)
wynik3_givens$Q
wynik3_givens$R
```

Rozk?ad algorytmem qr_householder:

```{r}
wynik3_householder = qr_householer(M_3)
wynik3_householder$Q
wynik3_householder$R
```

B??d bezwgld?ny z rozk?adu QR metod? rotacji Givensa:

```{r}
M_3_givens = wynik3_givens$Q  %*% wynik3_givens$R
M_31 = M_3_givens - M_3
blad_givens_M_3 = norm(M_31)
blad_givens_M_3
```

B??d bezwzgl?dny z rozk?adu QR funkcj? wbudowan? w j?zyk R:

```{r}
M_3_qr = qr.Q(QR) %*% qr.R(QR)
M_32 = M_3_qr - M_3
blad_qr_M_3 = norm(M_32)
blad_qr_M_3
```

B??d bezwzgl?dy z rozk?adu QR metod? odbi? Householdera:

```{r}
M_3_householder = wynik3_householder$Q %*% wynik3_householder$R
M_33 = M_3_householder - M_3
blad_householder_M_3 = norm(M_33)
blad_householder_M_3

```

```{r}
min(blad_givens_M_3,blad_householder_M_3,blad_qr_M_3)
max(blad_givens_M_3,blad_householder_M_3,blad_qr_M_3)

```